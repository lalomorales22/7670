<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Trippy Visualization Extravaganza</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css">
    <style>
        body { margin: 0; background: #000; color: #fff; font-family: Arial, sans-serif; }
        .sidebar { background: #111; color: #fff; min-height: 100vh; }
        .sidebar .nav-link { color: #bbb; cursor: pointer; }
        .sidebar .nav-link.active { background: #222; color: #fff; }
        .hero-banner { background: #222; padding: 20px; color: #fff; }
        #controls { position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; z-index: 1000; }
        #controls button { background: #4CAF50; border: none; color: white; padding: 8px 12px; font-size: 14px; margin: 4px 2px; cursor: pointer; border-radius: 5px; }
        .canvas-container { position: relative; width: 100%; height: calc(100vh - 100px); }
        .modal-content { background-color: #222; color: #fff; }
        .modal-header, .modal-footer { border: none; }
        .form-control, .custom-select { background-color: #333; color: #fff; border: none; }
    </style>
</head>
<body>
    <div class="d-flex">
        <!-- Sidebar -->
        <nav class="sidebar p-3">
            <h5>Visualizations</h5>
            <ul class="nav flex-column">
                {% for vis in visualizations %}
                <li class="nav-item">
                    <a class="nav-link" data-vis-id="{{ vis.id }}">{{ vis.name }}</a>
                </li>
                {% endfor %}
            </ul>
        </nav>
        <!-- Main Content -->
        <div class="flex-grow-1">
            <!-- Hero Banner -->
            <div class="hero-banner text-center">
                <h1>Trippy Visualization Extravaganza</h1>
                <p>Experience mesmerizing visuals and dive into a world of colors and patterns.</p>
            </div>
            <!-- Visualization Area -->
            <div id="controls">
                <button onclick="toggleAnimation()">Stop/Start</button>
                <button onclick="saveImage()">Save Image</button>
                <button onclick="switchVisualization()">Switch Visualization</button>
                <button onclick="openSettings()">Settings</button>
            </div>
            <div class="canvas-container" id="visContainer"></div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal fade" id="settingsModal" tabindex="-1" aria-labelledby="settingsModalLabel">
      <div class="modal-dialog">
        <div class="modal-content text-white">
          <div class="modal-header">
            <h5 class="modal-title" id="settingsModalLabel">Visualization Settings</h5>
            <button type="button" class="close text-white" data-dismiss="modal">
              <span>&times;</span>
            </button>
          </div>
          <div class="modal-body">
            <form id="settingsForm">
              <div class="form-group">
                <label for="speedControl">Speed</label>
                <input type="range" class="form-control-range" id="speedControl" min="0.1" max="5" step="0.1" value="1">
              </div>
              <div class="form-group">
                <label for="colorScheme">Color Scheme</label>
                <select class="custom-select" id="colorScheme">
                  <option value="default">Default</option>
                  <option value="rainbow">Rainbow</option>
                  <option value="monochrome">Monochrome</option>
                </select>
              </div>
            </form>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-primary" onclick="applySettings()">Apply</button>
            <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
          </div>
        </div>
      </div>
    </div>

    <!-- JS scripts -->
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.bundle.min.js"></script>
    <!-- Visualization Scripts -->
    <script>
        let currentVis = 0;
        const visualizations = [
            { name: 'Fractal Tree', func: createFractalTree },
            { name: 'Psychedelic Vortex', func: createPsychedelicVortex },
            { name: 'Neon Waves', func: createNeonWaves },
            { name: 'Kaleidoscope', func: createKaleidoscope },
            { name: 'Particle Explosion', func: createParticleExplosion },
            { name: 'Matrix Rain', func: createMatrixRain },
            { name: 'Fireworks', func: createFireworks },
            { name: 'Gravity Balls', func: createGravityBalls },
            { name: 'Perlin Noise Flow Field', func: createPerlinNoiseFlowField },
            { name: 'Mandelbrot Set', func: createMandelbrotSet },
            { name: 'Starfield', func: createStarfield },
            { name: '3D Rotating Cube', func: createRotatingCube },
            { name: 'Circular Wave', func: createCircularWave },
            { name: 'Spiral Galaxy', func: createSpiralGalaxy },
            { name: 'Lightning Effect', func: createLightningEffect },
            { name: 'Colorful Spirograph', func: createSpirograph },
            { name: 'Audio Visualizer', func: createAudioVisualizer },
            { name: 'Hypnotic Squares', func: createHypnoticSquares },
            { name: 'Metaballs', func: createMetaballs }
        ];

        function initializeVisualization() {
            if (typeof window.toggleAnimationFunction === 'function') {
                window.toggleAnimationFunction(true); // Stop previous animation
            }
            const container = document.getElementById('visContainer');
            container.innerHTML = '<canvas id="canvas"></canvas>';
            visualizations[currentVis].func();
            updateActiveNavLink();
        }

        function switchVisualization() {
            currentVis = (currentVis + 1) % visualizations.length;
            initializeVisualization();
        }

        function toggleAnimation() {
            if (typeof window.toggleAnimationFunction === 'function') {
                window.toggleAnimationFunction();
            }
        }

        function saveImage() {
            const canvas = document.getElementById('canvas');
            const image = canvas.toDataURL("image/png").replace("image/png", "image/octet-stream");
            const link = document.createElement('a');
            link.download = "trippy-vis.png";
            link.href = image;
            link.click();
        }

        function updateActiveNavLink() {
            document.querySelectorAll('.sidebar .nav-link').forEach((link, index) => {
                if (index === currentVis) {
                    link.classList.add('active');
                } else {
                    link.classList.remove('active');
                }
            });
        }

        // Event listeners for sidebar links
        document.querySelectorAll('.sidebar .nav-link').forEach((link, index) => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                currentVis = index;
                initializeVisualization();
            });
        });

        function openSettings() {
            $('#settingsModal').modal('show');
        }

        function applySettings() {
            let speed = parseFloat(document.getElementById('speedControl').value);
            let colorScheme = document.getElementById('colorScheme').value;

            if (typeof window.applyVisualizationSettings === 'function') {
                window.applyVisualizationSettings({ speed: speed, colorScheme: colorScheme });
            }

            $('#settingsModal').modal('hide');
        }

        // Visualization functions
        // Visualization functions
function createFractalTree() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let animationId;
    let angle = 0;
    let speed = 0.1;
    let isAnimating = true;
    let colorScheme = 'default';

    function resize() {
        canvas.width = window.innerWidth - document.querySelector('.sidebar').offsetWidth;
        canvas.height = window.innerHeight - document.querySelector('.hero-banner').offsetHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    function drawTree(startX, startY, len, angle, branchWidth) {
        ctx.beginPath();
        ctx.save();
        let hue = colorScheme === 'monochrome' ? 0 : (angle % 360);
        if (colorScheme === 'rainbow') hue = Math.random() * 360;
        ctx.strokeStyle = `hsl(${hue}, 100%, 50%)`;
        ctx.lineWidth = branchWidth;
        ctx.translate(startX, startY);
        ctx.rotate(angle * Math.PI / 180);
        ctx.moveTo(0, 0);
        ctx.lineTo(0, -len);
        ctx.stroke();

        if (len < 10) {
            ctx.restore();
            return;
        }

        drawTree(0, -len, len * 0.8, angle - 15, branchWidth * 0.8);
        drawTree(0, -len, len * 0.8, angle + 15, branchWidth * 0.8);

        ctx.restore();
    }

    function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawTree(canvas.width / 2, canvas.height, canvas.height / 4, angle, 10);
        angle += speed;
        animationId = requestAnimationFrame(animate);
    }

    animate();

    window.toggleAnimationFunction = function (stop) {
        if (stop) {
            cancelAnimationFrame(animationId);
            isAnimating = false;
            return;
        }
        if (isAnimating) {
            cancelAnimationFrame(animationId);
            isAnimating = false;
        } else {
            animate();
            isAnimating = true;
        }
    };

    window.applyVisualizationSettings = function (settings) {
        speed = settings.speed * 0.1; // Adjust speed scaling
        colorScheme = settings.colorScheme;
    };
}

function createPsychedelicVortex() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let animationId;
    let time = 0;
    let speed = 0.01;
    let isAnimating = true;
    let colorScheme = 'default';

    function resize() {
        canvas.width = window.innerWidth - document.querySelector('.sidebar').offsetWidth;
        canvas.height = window.innerHeight - document.querySelector('.hero-banner').offsetHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    function drawVortex() {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        for (let i = 0; i < 100; i++) {
            const angle = 0.1 * i + time;
            const x = centerX + angle * Math.cos(angle) * 10;
            const y = centerY + angle * Math.sin(angle) * 10;
            let hue = (time * 100 + i * 3) % 360;
            if (colorScheme === 'monochrome') hue = 0;
            else if (colorScheme === 'rainbow') hue = Math.random() * 360;
            ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, Math.PI * 2);
            ctx.fill();
        }

        time += speed;
    }

    function animate() {
        drawVortex();
        animationId = requestAnimationFrame(animate);
    }

    animate();

    window.toggleAnimationFunction = function (stop) {
        if (stop) {
            cancelAnimationFrame(animationId);
            isAnimating = false;
            return;
        }
        if (isAnimating) {
            cancelAnimationFrame(animationId);
            isAnimating = false;
        } else {
            animate();
            isAnimating = true;
        }
    };

    window.applyVisualizationSettings = function (settings) {
        speed = settings.speed * 0.01; // Adjust speed scaling
        colorScheme = settings.colorScheme;
    };
}


function createNeonWaves() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let animationId;
    let time = 0;
    let speed = 0.05;
    let isAnimating = true;
    let colorScheme = 'default';

    function resize() {
        canvas.width = window.innerWidth - document.querySelector('.sidebar').offsetWidth;
        canvas.height = window.innerHeight - document.querySelector('.hero-banner').offsetHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    function drawWaves() {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        for (let i = 0; i < 5; i++) {
            ctx.beginPath();
            ctx.moveTo(0, canvas.height / 2);
            for (let x = 0; x < canvas.width; x++) {
                const y = Math.sin(x * 0.01 + time + i) * 100 + canvas.height / 2;
                ctx.lineTo(x, y);
            }
            let hue = (time * 200 + i * 70) % 360;
            if (colorScheme === 'monochrome') hue = 0;
            else if (colorScheme === 'rainbow') hue = Math.random() * 360;
            ctx.strokeStyle = `hsl(${hue}, 100%, 50%)`;
            ctx.lineWidth = 5;
            ctx.stroke();
        }

        time += speed;
    }

    function animate() {
        drawWaves();
        animationId = requestAnimationFrame(animate);
    }

    animate();

    window.toggleAnimationFunction = function(stop) {
        if (stop) {
            cancelAnimationFrame(animationId);
            isAnimating = false;
            return;
        }
        if (isAnimating) {
            cancelAnimationFrame(animationId);
            isAnimating = false;
        } else {
            animate();
            isAnimating = true;
        }
    };

    window.applyVisualizationSettings = function(settings) {
        speed = settings.speed * 0.05; // Adjust speed scaling
        colorScheme = settings.colorScheme;
    };
}


function createKaleidoscope() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let animationId;
    let time = 0;
    let speed = 0.01;
    let isAnimating = true;
    let colorScheme = 'default';

    function resize() {
        canvas.width = window.innerWidth - document.querySelector('.sidebar').offsetWidth;
        canvas.height = window.innerHeight - document.querySelector('.hero-banner').offsetHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    function drawKaleidoscope() {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const radius = Math.min(centerX, centerY);

        for (let i = 0; i < 12; i++) {
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate((Math.PI / 6) * i + time);

            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(radius * Math.cos(Math.PI / 12), radius * Math.sin(Math.PI / 12));
            ctx.lineTo(radius * Math.cos(-Math.PI / 12), radius * Math.sin(-Math.PI / 12));
            ctx.closePath();

            let hue1 = (time * 100 + i * 30) % 360;
            let hue2 = (hue1 + 180) % 360;
            if (colorScheme === 'monochrome') {
                hue1 = hue2 = 0;
            } else if (colorScheme === 'rainbow') {
                hue1 = Math.random() * 360;
                hue2 = Math.random() * 360;
            }

            const gradient = ctx.createLinearGradient(0, 0, radius, 0);
            gradient.addColorStop(0, `hsl(${hue1}, 100%, 50%)`);
            gradient.addColorStop(1, `hsl(${hue2}, 100%, 50%)`);

            ctx.fillStyle = gradient;
            ctx.fill();

            ctx.restore();
        }

        time += speed;
    }

    function animate() {
        drawKaleidoscope();
        animationId = requestAnimationFrame(animate);
    }

    animate();

    window.toggleAnimationFunction = function(stop) {
        if (stop) {
            cancelAnimationFrame(animationId);
            isAnimating = false;
            return;
        }
        if (isAnimating) {
            cancelAnimationFrame(animationId);
            isAnimating = false;
        } else {
            animate();
            isAnimating = true;
        }
    };

    window.applyVisualizationSettings = function(settings) {
        speed = settings.speed * 0.01; // Adjust speed scaling
        colorScheme = settings.colorScheme;
    };
}


function createParticleExplosion() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let particles = [];
    let animationId;
    let isAnimating = true;
    let speed = 1;
    let colorScheme = 'default';

    function resize() {
        canvas.width = window.innerWidth - document.querySelector('.sidebar').offsetWidth;
        canvas.height = window.innerHeight - document.querySelector('.hero-banner').offsetHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    function createParticles() {
        particles = [];
        for (let i = 0; i < 500; i++) {
            particles.push({
                x: canvas.width / 2,
                y: canvas.height / 2,
                vx: (Math.random() - 0.5) * 5 * speed,
                vy: (Math.random() - 0.5) * 5 * speed,
                alpha: 1
            });
        }
    }

    function drawParticles() {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        particles.forEach(p => {
            p.x += p.vx;
            p.y += p.vy;
            p.alpha -= 0.01 * speed;

            let hue = 200;
            if (colorScheme === 'rainbow') hue = Math.random() * 360;
            else if (colorScheme === 'monochrome') hue = 0;

            ctx.fillStyle = `hsla(${hue}, 100%, 50%, ${p.alpha})`;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
            ctx.fill();
        });

        particles = particles.filter(p => p.alpha > 0);
        if (particles.length === 0) {
            createParticles();
        }
    }

    function animate() {
        drawParticles();
        animationId = requestAnimationFrame(animate);
    }

    createParticles();
    animate();

    window.toggleAnimationFunction = function(stop) {
        if (stop) {
            cancelAnimationFrame(animationId);
            isAnimating = false;
            return;
        }
        if (isAnimating) {
            cancelAnimationFrame(animationId);
            isAnimating = false;
        } else {
            animate();
            isAnimating = true;
        }
    };

    window.applyVisualizationSettings = function(settings) {
        speed = settings.speed;
        colorScheme = settings.colorScheme;
    };
}


function createMatrixRain() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let animationId;
    let isAnimating = true;
    let speed = 1;
    let colorScheme = 'default';

    const fontSize = 16;
    let columns;
    let drops;
    const characters = 'アカサタナハマヤラワ0123456789';

    function resize() {
        canvas.width = window.innerWidth - document.querySelector('.sidebar').offsetWidth;
        canvas.height = window.innerHeight - document.querySelector('.hero-banner').offsetHeight;
        columns = Math.floor(canvas.width / fontSize);
        drops = Array(columns).fill(1);
    }
    window.addEventListener('resize', resize);
    resize();

    function drawMatrix() {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = colorScheme === 'monochrome' ? '#0F0' : `hsl(${Math.random() * 360}, 100%, 50%)`;
        ctx.font = `${fontSize}px monospace`;

        for (let i = 0; i < drops.length; i++) {
            const text = characters.charAt(Math.floor(Math.random() * characters.length));
            ctx.fillText(text, i * fontSize, drops[i] * fontSize);

            if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                drops[i] = 0;
            }

            drops[i] += speed;
        }
    }

    function animate() {
        drawMatrix();
        animationId = requestAnimationFrame(animate);
    }

    animate();

    window.toggleAnimationFunction = function(stop) {
        if (stop) {
            cancelAnimationFrame(animationId);
            isAnimating = false;
            return;
        }
        if (isAnimating) {
            cancelAnimationFrame(animationId);
            isAnimating = false;
        } else {
            animate();
            isAnimating = true;
        }
    };

    window.applyVisualizationSettings = function(settings) {
        speed = settings.speed;
        colorScheme = settings.colorScheme;
    };
}


function createFireworks() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let fireworks = [];
    let particles = [];
    let animationId;
    let isAnimating = true;
    let speed = 1;
    let colorScheme = 'default';

    function resize() {
        canvas.width = window.innerWidth - document.querySelector('.sidebar').offsetWidth;
        canvas.height = window.innerHeight - document.querySelector('.hero-banner').offsetHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    function createFirework() {
        const x = Math.random() * canvas.width;
        const y = canvas.height;
        const targetY = Math.random() * canvas.height / 2;
        fireworks.push({ x, y, targetY, particlesCreated: false });
    }

    function drawFireworks() {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        fireworks.forEach((fw, index) => {
            ctx.beginPath();
            ctx.arc(fw.x, fw.y, 2, 0, Math.PI * 2);
            ctx.fillStyle = '#fff';
            ctx.fill();

            fw.y -= 5 * speed;

            if (fw.y <= fw.targetY && !fw.particlesCreated) {
                createParticles(fw.x, fw.y);
                fw.particlesCreated = true;
                fireworks.splice(index, 1);
            }
        });

        particles.forEach((p, index) => {
            p.x += p.vx * speed;
            p.y += p.vy * speed;
            p.alpha -= 0.02 * speed;

            let hue = p.hue;
            if (colorScheme === 'rainbow') hue = Math.random() * 360;
            else if (colorScheme === 'monochrome') hue = 0;

            ctx.fillStyle = `hsla(${hue}, 100%, 50%, ${p.alpha})`;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
            ctx.fill();

            if (p.alpha <= 0) {
                particles.splice(index, 1);
            }
        });

        if (Math.random() > 0.95) {
            createFirework();
        }
    }

    function createParticles(x, y) {
        for (let i = 0; i < 100; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speedValue = Math.random() * 5;
            particles.push({
                x: x,
                y: y,
                vx: Math.cos(angle) * speedValue,
                vy: Math.sin(angle) * speedValue,
                alpha: 1,
                hue: Math.random() * 360
            });
        }
    }

    function animate() {
        drawFireworks();
        animationId = requestAnimationFrame(animate);
    }

    animate();

    window.toggleAnimationFunction = function(stop) {
        if (stop) {
            cancelAnimationFrame(animationId);
            isAnimating = false;
            return;
        }
        if (isAnimating) {
            cancelAnimationFrame(animationId);
            isAnimating = false;
        } else {
            animate();
            isAnimating = true;
        }
    };

    window.applyVisualizationSettings = function(settings) {
        speed = settings.speed;
        colorScheme = settings.colorScheme;
    };
}


function createGravityBalls() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let balls = [];
    let animationId;
    let isAnimating = true;
    let speed = 1;
    let colorScheme = 'default';
    const gravity = 0.1;

    function resize() {
        canvas.width = window.innerWidth - document.querySelector('.sidebar').offsetWidth;
        canvas.height = window.innerHeight - document.querySelector('.hero-banner').offsetHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    function createBalls() {
        balls = [];
        for (let i = 0; i < 50; i++) {
            balls.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                vx: (Math.random() - 0.5) * 2 * speed,
                vy: (Math.random() - 0.5) * 2 * speed,
                radius: Math.random() * 20 + 10,
                color: Math.random() * 360
            });
        }
    }

    function drawBalls() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        balls.forEach(ball => {
            ball.vy += gravity * speed;
            ball.x += ball.vx * speed;
            ball.y += ball.vy * speed;

            if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) {
                ball.vx *= -1;
            }
            if (ball.y + ball.radius > canvas.height) {
                ball.vy *= -0.9; // Some energy loss
                ball.y = canvas.height - ball.radius;
            }

            let hue = ball.color;
            if (colorScheme === 'rainbow') hue = Math.random() * 360;
            else if (colorScheme === 'monochrome') hue = 0;

            ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    function animate() {
        drawBalls();
        animationId = requestAnimationFrame(animate);
    }

    createBalls();
    animate();

    window.toggleAnimationFunction = function(stop) {
        if (stop) {
            cancelAnimationFrame(animationId);
            isAnimating = false;
            return;
        }
        if (isAnimating) {
            cancelAnimationFrame(animationId);
            isAnimating = false;
        } else {
            animate();
            isAnimating = true;
        }
    };

    window.applyVisualizationSettings = function(settings) {
        speed = settings.speed;
        colorScheme = settings.colorScheme;
    };
}


function createPerlinNoiseFlowField() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let particles = [];
    let animationId;
    let isAnimating = true;
    let speed = 1;
    let colorScheme = 'default';
    const noiseScale = 0.01;
    let time = 0;

    function resize() {
        canvas.width = window.innerWidth - document.querySelector('.sidebar').offsetWidth;
        canvas.height = window.innerHeight - document.querySelector('.hero-banner').offsetHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    function createParticles() {
        particles = [];
        for (let i = 0; i < 500; i++) {
            particles.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                vx: 0,
                vy: 0,
                color: Math.random() * 360
            });
        }
    }

    function noise(x, y) {
        // Simple pseudo-random function as a placeholder for noise
        return Math.sin(x * noiseScale + time) * Math.cos(y * noiseScale + time);
    }

    function drawFlowField() {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        particles.forEach(p => {
            const angle = noise(p.x, p.y) * Math.PI * 2;
            p.vx = Math.cos(angle) * speed;
            p.vy = Math.sin(angle) * speed;
            p.x += p.vx;
            p.y += p.vy;

            if (p.x < 0) p.x = canvas.width;
            if (p.x > canvas.width) p.x = 0;
            if (p.y < 0) p.y = canvas.height;
            if (p.y > canvas.height) p.y = 0;

            let hue = p.color;
            if (colorScheme === 'rainbow') hue = Math.random() * 360;
            else if (colorScheme === 'monochrome') hue = 0;

            ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
            ctx.fillRect(p.x, p.y, 2, 2);
        });

        time += 0.01 * speed;
    }

    function animate() {
        drawFlowField();
        animationId = requestAnimationFrame(animate);
    }

    createParticles();
    animate();

    window.toggleAnimationFunction = function(stop) {
        if (stop) {
            cancelAnimationFrame(animationId);
            isAnimating = false;
            return;
        }
        if (isAnimating) {
            cancelAnimationFrame(animationId);
            isAnimating = false;
        } else {
            animate();
            isAnimating = true;
        }
    };

    window.applyVisualizationSettings = function(settings) {
        speed = settings.speed;
        colorScheme = settings.colorScheme;
    };
}


function createMandelbrotSet() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let isAnimating = false; // No animation for static Mandelbrot set
    let colorScheme = 'default';

    function resize() {
        canvas.width = window.innerWidth - document.querySelector('.sidebar').offsetWidth;
        canvas.height = window.innerHeight - document.querySelector('.hero-banner').offsetHeight;
        drawMandelbrot();
    }
    window.addEventListener('resize', resize);
    resize();

    function drawMandelbrot() {
        const maxIter = 100;
        const imgData = ctx.createImageData(canvas.width, canvas.height);
        const zoom = 200;

        for (let x = 0; x < canvas.width; x++) {
            for (let y = 0; y < canvas.height; y++) {
                let c_re = (x - canvas.width / 2) / zoom;
                let c_im = (y - canvas.height / 2) / zoom;
                let Z_re = c_re, Z_im = c_im;
                let isInside = true;
                let n;
                for (n = 0; n < maxIter; n++) {
                    let Z_re2 = Z_re * Z_re - Z_im * Z_im + c_re;
                    let Z_im2 = 2 * Z_re * Z_im + c_im;
                    Z_re = Z_re2;
                    Z_im = Z_im2;
                    if (Z_re * Z_re + Z_im * Z_im > 4) {
                        isInside = false;
                        break;
                    }
                }
                const idx = (x + y * canvas.width) * 4;
                let hue = (n / maxIter) * 360;
                if (colorScheme === 'monochrome') hue = 0;
                else if (colorScheme === 'rainbow') hue = (n / maxIter) * 360;
                if (isInside) {
                    imgData.data[idx] = 0;
                    imgData.data[idx + 1] = 0;
                    imgData.data[idx + 2] = 0;
                } else {
                    const color = hslToRgb(hue / 360, 1, 0.5);
                    imgData.data[idx] = color[0];
                    imgData.data[idx + 1] = color[1];
                    imgData.data[idx + 2] = color[2];
                }
                imgData.data[idx + 3] = 255;
            }
        }
        ctx.putImageData(imgData, 0, 0);
    }

    function hslToRgb(h, s, l) {
        let r, g, b;
        if (s == 0) {
            r = g = b = l;
        } else {
            const hue2rgb = function (p, q, t) {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1 / 6) return p + (q - p) * 6 * t;
                if (t < 1 / 2) return q;
                if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                return p;
            };
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
        }
        return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }

    window.toggleAnimationFunction = function (stop) {
        // Mandelbrot set is static; no animation to stop or start
    };

    window.applyVisualizationSettings = function (settings) {
        colorScheme = settings.colorScheme;
        drawMandelbrot();
    };
}


function createStarfield() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let stars = [];
    let animationId;
    let isAnimating = true;
    let speed = 2;
    let colorScheme = 'default';

    function resize() {
        canvas.width = window.innerWidth - document.querySelector('.sidebar').offsetWidth;
        canvas.height = window.innerHeight - document.querySelector('.hero-banner').offsetHeight;
        createStars();
    }
    window.addEventListener('resize', resize);
    resize();

    function createStars() {
        stars = [];
        for (let i = 0; i < 500; i++) {
            stars.push({
                x: Math.random() * canvas.width - canvas.width / 2,
                y: Math.random() * canvas.height - canvas.height / 2,
                z: Math.random() * canvas.width,
                color: Math.random() * 360
            });
        }
    }

    function drawStarfield() {
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        stars.forEach(star => {
            star.z -= speed;
            if (star.z <= 0) {
                star.x = Math.random() * canvas.width - canvas.width / 2;
                star.y = Math.random() * canvas.height - canvas.height / 2;
                star.z = canvas.width;
            }

            let sx = (star.x / star.z) * canvas.width + canvas.width / 2;
            let sy = (star.y / star.z) * canvas.height + canvas.height / 2;
            let radius = (1 - star.z / canvas.width) * 2;
            let hue = star.color;
            if (colorScheme === 'rainbow') hue = Math.random() * 360;
            else if (colorScheme === 'monochrome') hue = 0;

            ctx.fillStyle = `hsl(${hue}, 100%, 80%)`;
            ctx.beginPath();
            ctx.arc(sx, sy, radius, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    function animate() {
        drawStarfield();
        animationId = requestAnimationFrame(animate);
    }

    createStars();
    animate();

    window.toggleAnimationFunction = function (stop) {
        if (stop) {
            cancelAnimationFrame(animationId);
            isAnimating = false;
            return;
        }
        if (isAnimating) {
            cancelAnimationFrame(animationId);
            isAnimating = false;
        } else {
            animate();
            isAnimating = true;
        }
    };

    window.applyVisualizationSettings = function (settings) {
        speed = settings.speed * 2;
        colorScheme = settings.colorScheme;
    };
}

function createRotatingCube() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let angle = 0;
    let animationId;
    let isAnimating = true;
    let speed = 0.01;
    let colorScheme = 'default';

    function resize() {
        canvas.width = window.innerWidth - document.querySelector('.sidebar').offsetWidth;
        canvas.height = window.innerHeight - document.querySelector('.hero-banner').offsetHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    function drawCube() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const points = [
            { x: -1, y: -1, z: -1 },
            { x: 1, y: -1, z: -1 },
            { x: 1, y: 1, z: -1 },
            { x: -1, y: 1, z: -1 },
            { x: -1, y: -1, z: 1 },
            { x: 1, y: -1, z: 1 },
            { x: 1, y: 1, z: 1 },
            { x: -1, y: 1, z: 1 },
        ];

        const edges = [
            [0, 1], [1, 2], [2, 3], [3, 0],
            [4, 5], [5, 6], [6, 7], [7, 4],
            [0, 4], [1, 5], [2, 6], [3, 7]
        ];

        const projected = [];

        points.forEach(point => {
            const rotatedX = point.x * Math.cos(angle) - point.z * Math.sin(angle);
            const rotatedZ = point.x * Math.sin(angle) + point.z * Math.cos(angle);
            const rotatedY = point.y;

            const distance = 4;
            const fov = 200;
            const scale = fov / (distance + rotatedZ);

            const x = rotatedX * scale + canvas.width / 2;
            const y = rotatedY * scale + canvas.height / 2;

            projected.push({ x, y });
        });

        ctx.strokeStyle = 'white';
        edges.forEach(edge => {
            const p1 = projected[edge[0]];
            const p2 = projected[edge[1]];
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        });

        angle += speed;
    }

    function animate() {
        drawCube();
        animationId = requestAnimationFrame(animate);
    }

    animate();

    window.toggleAnimationFunction = function (stop) {
        if (stop) {
            cancelAnimationFrame(animationId);
            isAnimating = false;
            return;
        }
        if (isAnimating) {
            cancelAnimationFrame(animationId);
            isAnimating = false;
        } else {
            animate();
            isAnimating = true;
        }
    };

    window.applyVisualizationSettings = function (settings) {
        speed = settings.speed * 0.01;
        colorScheme = settings.colorScheme;
    };
}


function createCircularWave() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let time = 0;
    let animationId;
    let isAnimating = true;
    let speed = 0.05;
    let colorScheme = 'default';

    function resize() {
        canvas.width = window.innerWidth - document.querySelector('.sidebar').offsetWidth;
        canvas.height = window.innerHeight - document.querySelector('.hero-banner').offsetHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    function drawCircularWave() {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const maxRadius = Math.min(centerX, centerY);

        for (let i = 0; i < 10; i++) {
            const radius = (time * 50 + i * 20) % maxRadius;
            let hue = (time * 100 + i * 36) % 360;
            if (colorScheme === 'monochrome') hue = 0;
            else if (colorScheme === 'rainbow') hue = (time * 100 + i * 36) % 360;

            ctx.strokeStyle = `hsl(${hue}, 100%, 50%)`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.stroke();
        }

        time += speed;
    }

    function animate() {
        drawCircularWave();
        animationId = requestAnimationFrame(animate);
    }

    animate();

    window.toggleAnimationFunction = function(stop) {
        if (stop) {
            cancelAnimationFrame(animationId);
            isAnimating = false;
            return;
        }
        if (isAnimating) {
            cancelAnimationFrame(animationId);
            isAnimating = false;
        } else {
            animate();
            isAnimating = true;
        }
    };

    window.applyVisualizationSettings = function(settings) {
        speed = settings.speed * 0.05; // Adjust speed scaling
        colorScheme = settings.colorScheme;
    };
}

        function createSpiralGalaxy() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let stars = [];
    let animationId;
    let isAnimating = true;
    let speed = 0.01;
    let colorScheme = 'default';
    const numStars = 1000;
    const arms = 5;

    function resize() {
        canvas.width = window.innerWidth - document.querySelector('.sidebar').offsetWidth;
        canvas.height = window.innerHeight - document.querySelector('.hero-banner').offsetHeight;
        createStars();
    }
    window.addEventListener('resize', resize);
    resize();

    function createStars() {
        stars = [];
        for (let i = 0; i < numStars; i++) {
            const arm = i % arms;
            const angle = (i / numStars) * Math.PI * 2 * arms;
            const distance = Math.random() * canvas.width / 2;
            stars.push({
                angle: angle,
                distance: distance,
                speedOffset: Math.random() * 0.05,
                color: Math.random() * 360
            });
        }
    }

    function drawGalaxy() {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        stars.forEach(star => {
            star.angle += speed + star.speedOffset;

            const x = centerX + star.distance * Math.cos(star.angle);
            const y = centerY + star.distance * Math.sin(star.angle);

            let hue = star.color;
            if (colorScheme === 'rainbow') hue = (star.color + star.angle * 50) % 360;
            else if (colorScheme === 'monochrome') hue = 0;

            ctx.fillStyle = `hsl(${hue}, 100%, 70%)`;
            ctx.fillRect(x, y, 2, 2);
        });
    }

    function animate() {
        drawGalaxy();
        animationId = requestAnimationFrame(animate);
    }

    animate();

    window.toggleAnimationFunction = function(stop) {
        if (stop) {
            cancelAnimationFrame(animationId);
            isAnimating = false;
            return;
        }
        if (isAnimating) {
            cancelAnimationFrame(animationId);
            isAnimating = false;
        } else {
            animate();
            isAnimating = true;
        }
    };

    window.applyVisualizationSettings = function(settings) {
        speed = settings.speed * 0.01; // Adjust speed scaling
        colorScheme = settings.colorScheme;
    };
}

        function createLightningEffect() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let animationId;
    let isAnimating = true;
    let colorScheme = 'default';
    let speed = 1;

    function resize() {
        canvas.width = window.innerWidth - document.querySelector('.sidebar').offsetWidth;
        canvas.height = window.innerHeight - document.querySelector('.hero-banner').offsetHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    function drawLightning() {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const startX = Math.random() * canvas.width;
        const startY = 0;
        const endX = Math.random() * canvas.width;
        const endY = canvas.height;

        let currentX = startX;
        let currentY = startY;
        const segments = 20;

        ctx.lineWidth = 2;
        let hue = 200;
        if (colorScheme === 'rainbow') hue = Math.random() * 360;
        else if (colorScheme === 'monochrome') hue = 0;

        ctx.strokeStyle = `hsl(${hue}, 100%, 80%)`;
        ctx.beginPath();
        ctx.moveTo(startX, startY);

        for (let i = 0; i < segments; i++) {
            const nextX = currentX + (endX - currentX) / (segments - i) + (Math.random() - 0.5) * 30;
            const nextY = currentY + (endY - currentY) / (segments - i) + Math.random() * 20;
            ctx.lineTo(nextX, nextY);
            currentX = nextX;
            currentY = nextY;
        }

        ctx.stroke();
    }

    function animate() {
        if (Math.random() > 0.95) {
            drawLightning();
        }
        animationId = requestAnimationFrame(animate);
    }

    animate();

    window.toggleAnimationFunction = function(stop) {
        if (stop) {
            cancelAnimationFrame(animationId);
            isAnimating = false;
            return;
        }
        if (isAnimating) {
            cancelAnimationFrame(animationId);
            isAnimating = false;
        } else {
            animate();
            isAnimating = true;
        }
    };

    window.applyVisualizationSettings = function(settings) {
        colorScheme = settings.colorScheme;
        speed = settings.speed;
    };
}

function createSpirograph() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let time = 0;
    let animationId;
    let isAnimating = true;
    let speed = 0.01;
    let colorScheme = 'default';

    function resize() {
        canvas.width = window.innerWidth - document.querySelector('.sidebar').offsetWidth;
        canvas.height = window.innerHeight - document.querySelector('.hero-banner').offsetHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    function drawSpirograph() {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const R = 150; // Fixed circle radius
        const r = 60;  // Moving circle radius
        const O = 80;  // Offset

        const x = (R - r) * Math.cos(time) + O * Math.cos(((R - r) / r) * time);
        const y = (R - r) * Math.sin(time) - O * Math.sin(((R - r) / r) * time);

        let hue = (time * 100) % 360;
        if (colorScheme === 'monochrome') hue = 0;
        else if (colorScheme === 'rainbow') hue = (time * 100) % 360;

        ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
        ctx.beginPath();
        ctx.arc(canvas.width / 2 + x, canvas.height / 2 + y, 2, 0, Math.PI * 2);
        ctx.fill();

        time += speed;
    }

    function animate() {
        drawSpirograph();
        animationId = requestAnimationFrame(animate);
    }

    animate();

    window.toggleAnimationFunction = function(stop) {
        if (stop) {
            cancelAnimationFrame(animationId);
            isAnimating = false;
            return;
        }
        if (isAnimating) {
            cancelAnimationFrame(animationId);
            isAnimating = false;
        } else {
            animate();
            isAnimating = true;
        }
    };

    window.applyVisualizationSettings = function(settings) {
        speed = settings.speed * 0.01; // Adjust speed scaling
        colorScheme = settings.colorScheme;
    };
}

function createAudioVisualizer() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let audioContext;
    let analyser;
    let dataArray;
    let animationId;
    let isAnimating = true;
    let colorScheme = 'default';
    let speed = 1; // Not used in this visualization

    function resize() {
        canvas.width = window.innerWidth - document.querySelector('.sidebar').offsetWidth;
        canvas.height = window.innerHeight - document.querySelector('.hero-banner').offsetHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    function initAudio() {
        navigator.mediaDevices.getUserMedia({ audio: true, video: false })
            .then(function(stream) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaStreamSource(stream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                const bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);
                source.connect(analyser);
                animate();
            })
            .catch(function(err) {
                console.error('Error accessing audio stream:', err);
            });
    }

    function drawVisualizer() {
        analyser.getByteFrequencyData(dataArray);
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const barWidth = (canvas.width / dataArray.length) * 2.5;
        let x = 0;

        for (let i = 0; i < dataArray.length; i++) {
            const barHeight = dataArray[i];
            let hue = (i * 10) % 360;
            if (colorScheme === 'monochrome') hue = 0;
            else if (colorScheme === 'rainbow') hue = (i * 10) % 360;

            ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
            ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);

            x += barWidth + 1;
        }
    }

    function animate() {
        if (!isAnimating) return;
        drawVisualizer();
        animationId = requestAnimationFrame(animate);
    }

    initAudio();

    window.toggleAnimationFunction = function(stop) {
        if (stop) {
            isAnimating = false;
            cancelAnimationFrame(animationId);
            if (audioContext) audioContext.suspend();
            return;
        }
        if (isAnimating) {
            isAnimating = false;
            cancelAnimationFrame(animationId);
            if (audioContext) audioContext.suspend();
        } else {
            isAnimating = true;
            if (audioContext) audioContext.resume();
            animate();
        }
    };

    window.applyVisualizationSettings = function(settings) {
        colorScheme = settings.colorScheme;
        // Speed is not applicable in this visualization
    };
}

function createHypnoticSquares() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let time = 0;
    let animationId;
    let isAnimating = true;
    let speed = 0.05;
    let colorScheme = 'default';

    function resize() {
        canvas.width = window.innerWidth - document.querySelector('.sidebar').offsetWidth;
        canvas.height = window.innerHeight - document.querySelector('.hero-banner').offsetHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    function drawSquares() {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const maxSize = Math.min(canvas.width, canvas.height);
        const numSquares = 20;

        for (let i = 0; i < numSquares; i++) {
            const size = maxSize * (i / numSquares);
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.rotate(time + i * 0.1);
            let hue = (i * 20 + time * 100) % 360;
            if (colorScheme === 'monochrome') hue = 0;
            else if (colorScheme === 'rainbow') hue = (i * 20 + time * 100) % 360;
            ctx.strokeStyle = `hsl(${hue}, 100%, 50%)`;
            ctx.lineWidth = 2;
            ctx.strokeRect(-size / 2, -size / 2, size, size);
            ctx.restore();
        }

        time += speed;
    }

    function animate() {
        drawSquares();
        animationId = requestAnimationFrame(animate);
    }

    animate();

    window.toggleAnimationFunction = function(stop) {
        if (stop) {
            cancelAnimationFrame(animationId);
            isAnimating = false;
            return;
        }
        if (isAnimating) {
            cancelAnimationFrame(animationId);
            isAnimating = false;
        } else {
            animate();
            isAnimating = true;
        }
    };

    window.applyVisualizationSettings = function(settings) {
        speed = settings.speed * 0.05;
        colorScheme = settings.colorScheme;
    };
}

function createMetaballs() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let animationId;
    let isAnimating = true;
    let speed = 1;
    let colorScheme = 'default';
    const numBalls = 10;
    let balls = [];

    function resize() {
        canvas.width = window.innerWidth - document.querySelector('.sidebar').offsetWidth;
        canvas.height = window.innerHeight - document.querySelector('.hero-banner').offsetHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    function initBalls() {
        balls = [];
        for (let i = 0; i < numBalls; i++) {
            balls.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                vx: (Math.random() - 0.5) * 2 * speed,
                vy: (Math.random() - 0.5) * 2 * speed,
                radius: Math.random() * 50 + 30
            });
        }
    }

    function drawMetaballs() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const imageData = ctx.createImageData(canvas.width, canvas.height);
        const data = imageData.data;

        for (let y = 0; y < canvas.height; y += 2) {
            for (let x = 0; x < canvas.width; x += 2) {
                let sum = 0;
                balls.forEach(ball => {
                    const dx = x - ball.x;
                    const dy = y - ball.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    sum += (ball.radius * ball.radius) / (dist * dist);
                });

                const idx = (x + y * canvas.width) * 4;
                if (sum >= 1) {
                    let hue = (sum * 100) % 360;
                    if (colorScheme === 'monochrome') hue = 0;
                    else if (colorScheme === 'rainbow') hue = (sum * 100) % 360;
                    const color = hslToRgb(hue / 360, 1, 0.5);
                    data[idx] = color[0];
                    data[idx + 1] = color[1];
                    data[idx + 2] = color[2];
                    data[idx + 3] = 255;
                } else {
                    data[idx + 3] = 0;
                }
            }
        }

        ctx.putImageData(imageData, 0, 0);

        balls.forEach(ball => {
            ball.x += ball.vx * speed;
            ball.y += ball.vy * speed;

            if (ball.x < 0 || ball.x > canvas.width) ball.vx *= -1;
            if (ball.y < 0 || ball.y > canvas.height) ball.vy *= -1;
        });
    }

    function hslToRgb(h, s, l) {
        let r, g, b;
        if (s == 0) {
            r = g = b = l;
        } else {
            const hue2rgb = function(p, q, t) {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            };
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1/3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1/3);
        }
        return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }

    function animate() {
        drawMetaballs();
        animationId = requestAnimationFrame(animate);
    }

    initBalls();
    animate();

    window.toggleAnimationFunction = function(stop) {
        if (stop) {
            cancelAnimationFrame(animationId);
            isAnimating = false;
            return;
        }
        if (isAnimating) {
            cancelAnimationFrame(animationId);
            isAnimating = false;
        } else {
            animate();
            isAnimating = true;
        }
    };

    window.applyVisualizationSettings = function(settings) {
        speed = settings.speed;
        colorScheme = settings.colorScheme;
    };
}

        // Initialize first visualization
        initializeVisualization();
    </script>
</body>
</html>
<!-- #region -->